

- [아파치 카프카 for beginners](#아파치-카프카-for-beginners)
- [sec-1 아파치 카프카 기초](#sec-1-아파치-카프카-기초)
  - [카프가 해결하려는 문제](#카프가-해결하려는-문제)
  - [카프카 - 토픽](#카프카---토픽)
    - [컨슈머가 다수인 경우의 작동](#컨슈머가-다수인-경우의-작동)
    - [파티션이 다수인 경우의 작동](#파티션이-다수인-경우의-작동)
  - [브로커, Replication, ISR(In-Sync-Replication)](#브로커-replication-isrin-sync-replication)
    - [브로커](#브로커)
    - [Replication](#replication)
    - [ISR(In Sync Replica)](#isrin-sync-replica)
    - [Replication](#replication-1)
  - [파티셔너(Partitioner)란?](#파티셔너partitioner란)
  - [컨슈머 랙(Consumer Lag)이란?](#컨슈머-랙consumer-lag이란)


# 아파치 카프카 for beginners


ref : https://www.inflearn.com/course/%EC%95%84%ED%8C%8C%EC%B9%98-%EC%B9%B4%ED%94%84%EC%B9%B4-%EC%9E%85%EB%AC%B8/lecture/67221?tab=curriculum

# sec-1 아파치 카프카 기초


## 카프가 해결하려는 문제  


다수의 Apps and Services 와 다수의 (RDB, Warehouse, Key-value Store) 가 있다.    
비즈니스 규모가 점점 커지면서 각 서비스간에 커플링이 강하게 된다.  
이는 장애처리가 어렵고 확장의 비용이 점점 커진다.    
( 거미줄 처럼 연결된 여러 백앤드 서버와 DB들을 20개정도 생각해보자. )  


카프카는 이 사이에서 결합도를 약하게 만들어주는 중계자 역할을 해준다.   
저장소들을 Producer Service 라고 보고, 데이터가 필요한 곳은 Consumer Service 라고 본다.  
데이터의 흐름을 Topic 별로 전달 해 주며 , 고가용성, 낮은 지연 등의 특징을 가진다.  



## 카프카 - 토픽  

### 컨슈머가 다수인 경우의 작동  

카프카의 데이터 전달을 여러 큐가 있고 각 큐를 토픽으로 볼 수 있다.   
토픽은 데이터의 목적(클릭 로그, 푸쉬전송, 위치정보로그)을 단위로 구분한다.  

토픽은 여러개의 파티션으로 구성  

- 첫번째 파티션은 0 번부터 시작한다.  
- 프로듀서는 데이터를 큐 구조에 쌓는다.  
- 컨슈머는 0번 데이터를 순차적으로 소비한다.  
- 이때 소비한 데이터를 사라지지 않는다.   


- 새로운 컨슈머가 붙었을때, 파티션의 데이터를 처음부터 읽게 된다.   
- ( 다른 컨슈머 그룹이고, auto.offset.reset = earliest )  
- 동일 데이터를 다른 컨슈머가 소비하는 특징이 아주 중요  
- eg) 
- 1. 클릭로그 분석&시각화 - 엘라스틱 서치(컨슈머 1)  
- 2. 클릭로그 백업 - 하둡 저장 ( 컨슈머 2) 


### 파티션이 다수인 경우의 작동  

key의 설정 유무에 따라서, 파티션에 할당하는 방식을 달리할 수 있음  
1. key = null,  기본 파티셔너 사용 -> 라운드 로빈으로 할당   
2. key != null, 기본 파티셔너 사용 -> 키의 해시값을 구해 특정 파티션에 할당  


파티션을 늘리는건 가능하지만, 줄이는건 불가능 하다.    
파티션을 늘려서 다수의 컨슈머에게 데이터 처리를 분산할 수 있다.  

파티션의 데이터 삭제는 옵션에 따라 다르다.   
- log.retention.ms : 최대 record 보존 시간   
- log.retention.byte : 최대 record 보존 크기 byte  



## 브로커, Replication, ISR(In-Sync-Replication)  

### 브로커  

카프카 브로커 : 카프카가 설치되어 있는 서버 단위  
- 3개 이상의 다른 (지역) 서버로 구성하는 것을 권장  

### Replication

레플리케이션 : 파티션을 복제해서, 다른 브로커(서버)에 저장 가능   

- 레플리케이션은 브로커의 갯수보다 많을 수 없다.  
- 원본 파티션은 - leader partition, 복제 파티션은 - follower partition. 
- 프로듀서가 데이터를 할당할때, 전달하는 대상은 리더 파티션이다.  


### ISR(In Sync Replica)

리더+팔로워 파티션을 합쳐서 말함     

- 프로듀서 ACK 라는 옵션 ( 고가용성을 위함  ) : 0 | 1 | all. 

  - ack = 0 : 데이터를 리더 파이션에 전달하고, 응답받지 않는다.  
    - ( 속도는 빠르지만, 데이터가 잘 전달되고, 복제되었는지 모른다. )

  - ack = 1 : 데이터를 리더 파이션에 전달하고, 응답받음.  
    - ( 리더 파티션까지 데이터전달이 됨을 확인하고, 복제성공여부는 모름. )  

  - ack = all : ack 1 옵션에 팔로우 파티션까지 데이터를 잘 저장됨을 확인  
    - ( 속도가 현저히 느리지만, 데이터의 유실은 없다. )  

- 브로커 3개 이상시 레플리케이션을 3으로 유지하는 것을 추천  
- 너무 많은 레플리카는 리소스소비가 커진다.  

### Replication

- 서버 장애시 고가용성 보장  

--- 

## 파티셔너(Partitioner)란?

카프카 프로듀셔의 중요 개념중 하나, 파티션을 효과적으로 사용   

프로듀서 앱에서는, 레코드(토픽,메시지 키,메시지 값) 정보를 파티셔너를 통해 브로커로 전달된다.  

파티셔너의 역할  
- 레코드를 토픽의 어떤 파티션에 넣을지 결정   
- 메시지 키,값에 따라서 파티션을 결정할 수 있다.  
- 기본값은 : uniformStickyPartitioner 로 결정  

- 메시지 키가 있는 경우  

  - hash(메시지키) => 파티션 번호 (동일키는 동일파티션에 들어감을 보장)  
  - 키 단위로, 데이터의 순서를 보장한다.(파티션=큐 이므로)  

- 메시지 키가 없는 경우  

  - 기본적으로 라운드 로빈 방식이지만  
  - 프로듀서에서 배치로 모을 수 있는 최대한의 레코드를 모아서 파티션으로 전달  
  - 이때, 라운드 로빈 방식으로 파티션에 돌아가면서 데이터를 넣는다.  

커스텀 파티셔너를 만들 수 있음  

  - 인터페이스 제공,
  - eg) VIP고객을 위해, 빠른 테이터 처리를 할 수 있다.  
  - 10개 파티션중 8개에 VIP 데이터를 넣어, 우선순위큐 효과를 누릴 수 있음.  

--- 

## 컨슈머 랙(Consumer Lag)이란?

모니터링 지표  

