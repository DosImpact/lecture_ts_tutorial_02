- 함수 시그니쳐

```ts
import IPerson from "./person/IPerson";
import Person, { makePerson } from "./person/Person";
import { makeRandomNumber } from "./utils/makeRandomNumber";

const maketwoPerson: (arg0: number) => void = (su: number): void => {
  let person01: IPerson = makePerson("doyoung", 352);
  let person02: IPerson = new Person("ddos");
  console.log(person01);
  console.log(person02);
};

maketwoPerson(0);
```

- type 정의

```ts
import IPerson from "./person/IPerson";
import Person, { makePerson } from "./person/Person";
import { makeRandomNumber } from "./utils/makeRandomNumber";

type generatePerson = (arg0: number, arg1?: string) => void;

const maketwoPerson: generatePerson = (su: number, name?: string): void => {
  let person01: IPerson = makePerson("doyoung", 352);
  let person02: IPerson = new Person("ddos");
  console.log(person01);
  console.log(person02);
};

maketwoPerson(0);
```

- 최하위 타입인 undefined 를 받을 수 있다.
- undefined에 대한 애러 처리를 해야한다.
- ESNext 이후 null 과 undefined 는 완전히 동일 하다.

```ts
interface IUndi {
  name: string;
}

function getName(arg: IUndi): void {
  if (arg === undefined) {
    return;
  }
  console.log(arg.name);
}

getName({ name: "hello" });
getName(undefined);
```

### first-class Function

- first-class function 함수를 제공하면, 함수형 프로그래밍이 가능하다.
- JS,TS 가 해당, 일등 함수는 함수와 변수를 차별하지 않는다는 뜻
- CF) 일등 시민 ( fist-class citizen) 은 로마시민과 속주국가의 시민이 같은 대우를 받는것.
- 변수 함수 가 동일 대우라면 일등 함수는 일등 시민이다 라는 말도 된다.

### eager evaluation vs lazy evaluation

- 1+2 는 바로 컴파일러에 의해 3 으로 계산 (eager)
- function expression : new Function('a','b','return a+b') : 는 a,b 는 아직 몰라서 계산을 보류 (lazy)

### 익명 함수

```ts
let result: number = ((a: number, b: number): number => a + b)(1, 2);

console.log(result);
```

### execution statement vs expression statement

```ts
- 실행문 | C 스타일 | CPU에서 실행되고 결과를 알려면 return 키워드가 있어야 한다.
const arrow1 = (a: number, b: number): number => {
  return a + b;
};
- 표현식 | return이 없어도 결과를 반환 |
const arrow2 = (a: number, b: number): number => a + b;
```

### 고차 함수 : 함수 실행 결과 또 함수를 반환한다.

```ts
const multiply = (a: number) => (b: number) => (c: number) => a * b * c;

console.log(multiply(11)(2)(3)); // 66

const add = (a: number) => (b: number): number => a + b;

console.log(add(10)(20)); // 30
```
